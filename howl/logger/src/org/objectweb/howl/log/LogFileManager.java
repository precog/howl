/*
 * JOnAS: Java(TM) Open Application Server
 * Copyright (C) 2004 Bull S.A.
 * Contact: jonas-team@objectweb.org
 * Created on Mar 25, 2004
 */
package org.objectweb.howl.log;

import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;

import java.nio.ByteBuffer;

/**
 * Manage a set of log files.
 * 
 * This class implements methods that can be called by LogBufferManager to obtain a LogFile for
 * logger IO and to signal the LogFileManager when new buffers are being initialized.  LogFileManager
 * manages log files according to implementation specific policies.
 * Some LogFileManagers may use a circular file policy while others may use a set of files.
 * The most simple implementations will use a single file and allow it to grow as needed.
 * 
 * QUESTION: do we need multiple implementations, or can we deal with different policies
 * in this one class using configuration?
 * 
 * @author Michael Giroux
 *
 */
class LogFileManager
{
  
  /**
   * maximum number of blocks to store in each LogFile.
   * 
   * <p>controls when logging is switched to a new log file, and/or when a circular
   *  log is reset to  seek address zero.
   * 
   * @see #getLogFile(LogBuffer)
   */
  int maxBlocksPerFile = Integer.MAX_VALUE;

  /**
   * The log key for the oldest active entry in the log.
   * 
   * <p>When automark is enabled (true) the <i> activeMark </i>
   * is updated after every put() operation.
   * When automark is disabled (as should be the case with JOTM)
   * the <i> activeMark </i> is updated manually by a call
   * to mark().
   * 
   * @see #mark(long)
   */
  long activeMark = 0;
  
  /**
   * indicates whether log files will be marked automatically.
   * <p>When automark is false, the <i> mark() </i> method must be
   * invoked by the log user.  When automark is true, the Logger
   * will automatically set the mark at the most recent record. 
   */
  boolean automark = false;
  
  /**
   * The automark value restored during log file initialization.
   * 
   * <p>if a set of log files exist from a prior execution, 
   * the value of automark is set based on the log file header
   * record processed during the init() processing.  The value
   * restored from the log file is saved in restartAutoMark
   * so it can be reported by getStats(). 
   */
  boolean restartAutoMark = false;
  
  /**
   * last key returned by  put().
   * 
   * @see #setCurrentKey(long)
   */
  private long currentKey = 0;
  
  /**
   * the first log key generated by this instance of the Logger.
   * 
   * <p>Initialized by <i> init() </i> to the block immediately
   * following the last block written in the prior execution.
   */
  private long initialKey = 0;
  
  /**
   * data written to log when autoMark is turned on
   */
  final byte[] autoMarkOn = new byte[] { 1 };
  
  /**
   * data written to log when autoMark is turned off
   */
  final byte[] autoMarkOff = new byte[] { 0 };

  /**
   * lock controlling access to LogFile.
   */
  private final Object fileManagerLock = new Object();
  
  
  /**
   * set of LogFile objects associated with the physical log files.
   * 
   * @see #open()
   */
  LogFile[] fileSet = null;
  
  /**
   * index to current entry in fileSet[]
   */
  short lfIndex = 0;

  LogFile currentLogFile = null;
  
  /**
   * number of log files to configure
   */
  int maxLogFiles = 2;
  
  /**
   * directory used to create log files
   */
  String logDir = ".";
  
  /**
   * file name extension for log files
   */
  String logFileExt = "log";
  
  /**
   * filename used to create log files.
   * <p>file names are generated using the following pattern:
   * <pre>
   *   <value of logFileName> + "_" + <file number> + "." + <value of logFileExt>
   * </pre>
   */
  String logFileName = "def";
  
  /**
   * LogFile header record.
   * 
   * <p>protected by fileManagerLock
   * 
   * <p>The first record of every LogFile is a FILE_HEADER record containing
   * information that is used during recovery to reposition the log file
   * and replay records starting from the active mark.
   * 
   * byte[1]  autoMark           byte[1]
   * long     activeMark         byte[8]  global to all log files
   * long     lowMark            byte[8]  low mark for current file == high mark for previous file
   * long     prevSwitchTod      byte[8]  time of previous file switch
   * int      fileSet.length     byte[4]  number of files in fileSet
   * int      maxBlocksPerFile   byte[4]  
   * byte[2]  crlf               byte[2]
   */
  byte[] fileHeader = new byte[35];
  
  /**
   * ByteBuffer wrapper for fileHeader to facilitate conversion of numeric
   * information to byte[] format.
   * 
   * <p>protected by fileManagerLock
   */
  ByteBuffer fileHeaderBB = ByteBuffer.wrap(fileHeader);
  
  /**
   * MARK control Record.
   * 
   * <p>A MARK control record containing the current state of the automark mode
   * and the active mark is stored at the beginning of every block.
   * This strategy allows the logger to read through a log file
   * looking only at the BSN for each block to locate the last written block.
   * Once the last written block is located, the current state of the MARK
   * can be obtained by examining the MARK record at the beginning of the
   * block.
   * 
   * <p>To avokd garbage collection for a byte[] and ByteBuffer wrapper for
   * each physical block, the class has a single markRecord member that is
   * protected by fileManagerLock.
   * 
   * <p>protected by fileManagerLock
   * 
   * byte[1]  autoMark           byte[1]
   * long     activeMark         byte[8]  global to all log files
   * int      fileSet.length     byte[4]  number of files in fileSet
   * int      maxBlocksPerFile   byte[4]  
   * byte[2]  crlf               byte[2]
   * 
   * @see #setMarkData(ByteBuffer)
   */
  byte[] markRecord = new byte[19];
  
  /**
   * ByteBuffer wrapper for markRecord to facilitate conversion of numeric
   * information to byte[] format.
   * 
   * <p>protected by fileManagerLock
   */
  ByteBuffer markRecordBB = ByteBuffer.wrap(markRecord);
  
  /**
   * end of line for log records to make logs readable in text editors.
   */
  byte[] crlf = "\r\n".getBytes();
  
  /**
   * LogBufferManager used by methods that put() records to the log.
   * <p>For example, the mark() method uses <i> bmgr </i> to put()
   * mark information to the log.
   */
  LogBufferManager bmgr;
  
  /**
   * The LogEventListener registered by the application that
   * owns the logger.  If <i> eventListener </i> is null then
   * the application is not notified of log events.
   */
  private LogEventListener eventListener = null;
  
  /**
   * Returns the LogFile that contains the requested <i> mark </i>.
   * <p>Called by LogBufferManager to locate a log file needed
   * for a replay() request.
   * 
   * @param mark A log key previously returned by LogBufferManager.put().
   * The log key is used to compute the desired file.
   * 
   * @return LogFile containing the requested <i> mark </i>.
   * <p>Returns null if none of the files in fileSet[] contain
   * the requested mark.
   */
  LogFile getLogFile(long mark)
  {
    LogFile lf = null;

    int fsl = fileSet.length;
    short lfIndex = (short)(this.lfIndex + 1);  // start looking at the oldest file
    
    for (int i=0; i < fsl; ++i)
    {
      lfIndex %= fsl;
      if (mark < fileSet[lfIndex].highMark)
      {
        lf = fileSet[lfIndex];
        break;
      }
      ++lfIndex;
    }

    return lf;
  }
  
  /**
   * Called by LogBuffer.init() to obtain the LogFile that will be used
   * to write a specific log block.
   * 
   * <p>The buffer sequence number of the LogBuffer parameter ( <i> lf.bsn</i> ) represents an
   * implementation specific value that is used to manage log file space. 
   * As buffers are written to disk the buffer
   * sequence number is incremented.
   * The LogFileManager is able to compute the seek
   * address for a buffer as a function of <i>lf.bsn</i> and buffer size.
   * 
   * <p>In all cases, getLogFile records a header record into the buffer
   * containing the current state of the automark mode and the current
   * active mark. 
   *  
   * @param lb LogBuffer that is asking for the LogFile.
   * LogFileManager implementations use <i> lf.bsn </i> to determine when to switch 
   * to a new file, or wrap a circular file back to seek address zero.
   * 
   * @return a LogFile to use for writing the LogBuffer
   */
  LogFile getLogFile(LogBuffer lb) throws LogFileOverflowException
  {
    try
    {
      synchronized(fileManagerLock)
      {
        if (currentLogFile == null || ((lb.bsn - 1) % maxBlocksPerFile) == 0)
        {
          int fsl = fileSet.length;
          lfIndex %= fsl;
          
          // Make sure active mark is not within the next log file. 
          LogFile nextLogFile = fileSet[lfIndex];
          assert nextLogFile != null: "nextLogFile == null";

          if (activeMark < nextLogFile.highMark)
            throw new LogFileOverflowException(activeMark, nextLogFile.highMark, nextLogFile.name);

          ++lfIndex;
          
          // remember the TOD we switched to this file
          nextLogFile.tod = System.currentTimeMillis();

          // fabricate log key for beginning of new bsn as high mark for current file
          // this value is used to compare with activeMark the next time this object is
          // reused.
          long highMark = lb.bsn << 24;
          
          // default tod for previous file switch is current file switch tod
          long switchTod = nextLogFile.tod;

          if (currentLogFile != null)
          {
            switchTod = currentLogFile.tod;
            currentLogFile.highMark = highMark;
          }
          
          // indicate that the new file must be rewound before this buffer is written
          lb.rewind = true;

          short type = LogRecordType.CTRL | LogRecordType.FILE_HEADER;
          
          fileHeaderBB.clear();
          fileHeaderBB.put(automark ? autoMarkOn : autoMarkOff);
          fileHeaderBB.putLong(activeMark);
          fileHeaderBB.putLong(highMark);
          fileHeaderBB.putLong(switchTod);
          fileHeaderBB.putInt(fileSet.length);
          fileHeaderBB.putInt(maxBlocksPerFile);
          fileHeaderBB.put(crlf);
          assert fileHeader.length == fileHeaderBB.position()
            : "byte[] fileHeader size error";
          
          lb.put(type, fileHeader, false);
          currentLogFile = nextLogFile;
        }
        else
        {
        	// initialize new block with a MARKKEY control record
        	short type = LogRecordType.CTRL | LogRecordType.MARKKEY;

          setMarkData(markRecordBB);
          assert markRecord.length == markRecordBB.position()
            : "byte[] markRecord size error";
          
          lb.put(type, markRecord, false);
          
          // TODO: detech 50% full and notify event listener
        }
      }
    } catch (LogRecordSizeException e) {
      // will never happen but use assert to catch during development
      assert e == null : "Unhandled LogRecordSizeException" + e;
    }
    
    return currentLogFile;
  }

  /**
   * generates MARKKEY data record into supplied <i> data </i> parameter.
   * 
   * @param data
   * ByteBuffer wrapping the target byte[]
   */
  void setMarkData(ByteBuffer data)
  {
    data.clear();
    data.put(automark ? autoMarkOn : autoMarkOff);
    data.putLong(activeMark);
    data.putInt(fileSet.length);
    data.putInt(maxBlocksPerFile);
    data.put(crlf);
  }
  
  /**
   * sets the LogFile's mark.
   * 
   * <p><i> mark() </i> provides a generalized method for callers
   * to inform the Logger that log space can be released
   * for reuse.
   *
   * <p>writes a MARKKEY control record to the log.
   * 
   * @param key is an opaque log key returned by a previous call
   * to put().
   * 
   * @return log key for the MARK record
   * 
   * @throws InvalidLogKeyException if <i> key </i> parameter is out of range.
   * key must be greater than current activeMark and less than the most recent
   * key returned by put().
   */
  long mark(long key)
    throws InvalidLogKeyException, IOException, InterruptedException
  {
    if (key < activeMark || key > currentKey)
      throw new InvalidLogKeyException(
          " key: " + Long.toHexString(key) +
          " activeMark: " + Long.toHexString(activeMark) +
          " currentKey: " + Long.toHexString(currentKey)
          );

    activeMark = key;

    byte[] markData = new byte[markRecord.length];
    ByteBuffer markDataBuffer = ByteBuffer.wrap(markData);

    short type = LogRecordType.CTRL | LogRecordType.MARKKEY;
    setMarkData(markDataBuffer);
    
    long markKey = 0L;
    try {
      markKey = bmgr.put(type, markData, false);
    }
    catch (LogRecordSizeException e) {
      // will never happen but use assert to catch during development
      assert e == null : "Unhandled LogRecordSizeException" + e;
    }
    catch (LogFileOverflowException e) {
      // should not happen since we just gave back some space
      // TODO: handle possible overflow here
    }
    
    return markKey;
  }
  
  /**
   * reads next block of data from the LogFile specified
   * by lb.lf. 
   * @param lb LogBuffer to read data into.
   * @return number of bytes read.
   * @throws IOException
   * returns -1 if no data available in file.
   */
  int read (LogBuffer lb) throws IOException
  {
    int bytesRead = lb.lf.channel.read(lb.buffer);
    return bytesRead;
  }
  
  /**
   * reads a block of data into LogBuffer <i> lb </i>.
   * <p>Amount of data read is determined by lb.capacity().
   * <p>sets lb.lf with the fileSet[] entry that contains
   * the requested BSN.
   * 
   * @param lb LogBuffer to read data into.
   * @param bsn block sequence number of the block to be read.
   * File position is computed as follows:
   * <ol>
   * <li>locate the entry within fileSet[] that contains the
   * requested bsn.
   * <li>compute position as (requested bsn - first bsn in file) * block size;
   * </ol>
   * @return number of bytes read.
   * returns -1 if no data available in file.
   * @see #read(lb)
   */
  int read(LogBuffer lb, int bsn) throws IOException
  {
    // TODO: locate file
    // TODO: set file position

    return read(lb);
  }
  
  /**
   * Sets the LogFile marking mode.
   * 
   * <p>writes an AUTOMARK control record to the log if the log
   * is open.
   * 
   * @param automark true to indicate automatic marking.
   */
  long setAutoMark(boolean automark)
    throws InvalidLogKeyException, IOException, InterruptedException, LogFileOverflowException
  {
    this.automark = automark;
    
    return mark(automark ? currentKey : activeMark);
    
  }

  /**
   * updates currentKey member variable.
   * 
   * <p>Method must be synchronized to guarantee that only
   * keys with larger values are assigned to currentKey.
   * 
   * @param key a log key returned by the buffer manager.
   * 
   * @see Logger#put(byte[],boolean) 
   */
  synchronized void setCurrentKey(long key)
  {
      if (key > currentKey) currentKey = key;
      if (automark) activeMark = currentKey;
  }
  
  /**
   * Registers a LogEventListener for log event notifications.
   * 
   * @param eventListener object to be notified of logger events.
   */
  void setLogEventListener(LogEventListener eventListener)
  {
    // QUESTION: does this need to be a list of listeners?
    this.eventListener = eventListener;
    
    // TODO: if current log file position is > 50% then notify NOW
  }

  /**
   * open pool of LogFile(s)
   * 
   * @throws FileNotFoundException
   * 
   * 
   * TODO: allow for restart parameter
   */
  void open()
    throws FileNotFoundException, InvalidFileSetException
  {
    // retrieve configuration information
    configure();
    
    // make sure we have at least two log files
    if (maxLogFiles < 2)
      throw new InvalidFileSetException("Must configure two or more files");
    
    // make sure the directory exists
    File dir = new File(logDir);
    dir.mkdirs();
    
    int existingFiles = 0;
    
    // allocate the set of log files
    fileSet = new LogFile[maxLogFiles];
    for (int i=0; i<maxLogFiles; ++i)
    {
      File name = new File(logDir + "/" + logFileName + "_" + (i+1) + "." + logFileExt);
      try
      {
        fileSet[i] = new LogFile(name).open();
        if (!fileSet[i].newFile)
        {
          // we have an existing file.  Mak sure all the files
          // prior to this one also existed
          // NOTE: this exception is only necessary if recovery requires
          //       use of the missing file.
          if (existingFiles != i)
            throw new InvalidFileSetException();

          // the count is correct -- go ahead and count this one
          ++existingFiles;
        }
      }
      catch (FileNotFoundException e)
      {
        // TODO: output log message 
        System.err.println(e + ":" + name);
        throw e;
      }
      
    }
    currentLogFile = null;
    
  }
  
  /**
   * validate LogFiles and set member variables.
   * 
   * <p>activeMark set based on last block written during previous execution.
   * <p>currentKey set to key of the last record written to the log.
   * <p>currentLogFile set to the next available LogFile in fileSet[] with
   * file position set to resume writing at the next block following the last block 
   * written.
   *
   */
  void init(LogBufferManager bmgr)
    throws IOException,
           LogConfigurationException, InvalidLogBufferException, InterruptedException
  {
    this.bmgr = bmgr;
    
    short lfIndex = 0;
    int bsn = 0;
    LogFile lf = null;
    
    LogBuffer lb = null;
    try { 
      lb = bmgr.getLogBuffer();
    } catch (ClassNotFoundException e) {
      lb = null;
    }
    if (lb == null)
      throw new LogConfigurationException("LogBuffer.class not found");
    
    lb.configure(bmgr, (short)-1);
    
    for (short i = 0; i < fileSet.length; ++i)
    {
      lf = fileSet[i];
      assert lf != null : "LogFile pointer lf is null";
      
      // skip newly created files
      if (lf.newFile) continue;
      
      lb.read(lf, 0L);
      
      // save previous file's highMark
      // these get moved into correct LogFile object later
      lf.highMark = ((long)lb.bsn) << 24;
      
      // locate the last file to be written
      if (lb.bsn > bsn)
      {
        bsn = lb.bsn;
        lfIndex = i;
      }
    }
    
    // move highMarks into previous LogFiles where they belong
    // start with fileSet entry following lfIndex and 
    // work around to entry preceding lfIndex.
    int fsl = fileSet.length;
    for (int i=1; i < fsl; ++i)
    {
      int n1 = (lfIndex + i) % fsl;
      int n2 = (n1 + 1) % fsl;
      fileSet[n1].highMark = fileSet[n2].highMark;
    }
    
    // reposition the last active file
    int blockSize = lb.buffer.capacity();
    currentLogFile = fileSet[lfIndex];
    this.lfIndex = (short)(lfIndex + 1);
    lf = currentLogFile;
    
    // compare file header with current configuration
    validateFileHeader(lb);

    // locate last block written starting in second block
    long fpos = blockSize;
    try {
      while(lb.read(lf, fpos).bsn > bsn) {
        fpos += blockSize;
        bsn = lb.bsn;
      }
    } catch (InvalidLogBufferException e) {
      /*
       * Ignore this exception here during restart processing.
       * An invalid block marks the end of the log.
       */
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
      throw e;
    }

    bmgr.init(this, bsn);
    
    // remember the initial key for this execution
    initialKey = (long) (bsn + 1) << 24;
    
    // initialize currentKey
    currentKey = initialKey;
    
    // update activeMark based on automark setting recovered from log
    if (automark) activeMark = currentKey;
    
    // process MARK control records in last block
    assert fpos > 0 : "Unexpected file postion: " + fpos;
    lb.read(lf, fpos-blockSize);
    LogRecord record = new LogRecord(lb.buffer.capacity());
    ByteBuffer dataBuffer = record.dataBuffer;
    short marktype = LogRecordType.CTRL | LogRecordType.MARKKEY;
    try {
      while (!record.get(lb).isEOB()) {
        if (record.type == marktype) {
          dataBuffer.clear();
          automark = dataBuffer.get() == 1 ? true : false;
          activeMark = dataBuffer.getLong();
        }
      }
    } catch (LogRecordSizeException e) {
      // cannot happen because record is same size as buffer
      assert e == null : "unhandled LogRecordSizeException";
    }
    
    // position current log file for writing
    lf.channel.position(fpos);
    
    // Write a RESTART record for replay
    short type = LogRecordType.CTRL | LogRecordType.RESTART;
    try {
      bmgr.put(type, new byte[0], false);
    } catch (InterruptedException e) {
      throw e;
    } catch (LogException e) {
      // should not happen, but if it does, we just ignore it here
      assert e == null : "unhandled LogException" + e.toString();
    } catch (IOException e) {
      // should not happen, but if it does, we just ignore it here
      assert e == null : "unhandled IOException";
    }

    // TODO: validate information against state file.
    //       a. define a state file and update during close
    //       b. validate current log information against state file
  }
  
  /**
   * Compares values in log file header record with current configuration.
   * <p>Throws LogConfigurationException if header does not match current
   * configuration.
   */
  void validateFileHeader(LogBuffer lb)
    throws LogConfigurationException, IOException, InvalidLogBufferException
  {
    LogFile lf = currentLogFile;
    
    lb.read(lf, 0L);
    if (lb.bsn == -1) return; // end of file or empty file

    LogRecord fh = new LogRecord(fileHeader.length);
    assert fh != null : "LogRecord reference [fh] is null";

    try {
      fh.get(lb);
      if (fh.type != (LogRecordType.CTRL | LogRecordType.FILE_HEADER) ||
          fh.length != fileHeader.length)
        throw new InvalidLogBufferException("HEADER_TYPE: " +
            Integer.toHexString(fh.type));
    } catch (LogRecordSizeException e) {
      throw new InvalidLogBufferException("FILEHEADER SIZE");
    }
    
    // we have a file header -- validate the data
    ByteBuffer dataBuffer = fh.dataBuffer;
    dataBuffer.clear();
    automark = dataBuffer.get() == 1 ? true : false;
    activeMark = dataBuffer.getLong();
    long highMark = dataBuffer.getLong();
    long switchTod = dataBuffer.getLong();
    
    /*
     * Mak sure we have at least as many files as we had
     * when the fileset was created initially.
     */
    int nFiles = dataBuffer.getInt();
    if (nFiles != fileSet.length)
      throw new LogConfigurationException("Current configuration number of files [" +
          fileSet.length + "] not equal number of files in set [" + nFiles + "]");
    
    /*
     * Make sure the configured file size is the same as
     * it was when the fileset was created.
     */
    int nBlocks = dataBuffer.getInt();
    if (nBlocks != maxBlocksPerFile)
      throw new LogConfigurationException("Configured file size [" +
          maxBlocksPerFile + "] blocks not equal previous file size [" + nBlocks + "] blocks");
    short crlf = dataBuffer.getShort();
    if (crlf != 0x0D0A)
      throw new InvalidLogBufferException("FILE_HEADER: expecting CRLF found " +
          Integer.toHexString(crlf));
    
    assert dataBuffer.capacity() == dataBuffer.position()
      : "byte[] fileHeader size error";
  }
  
  /**
   * Gracefully close the log files.
   * 
   * @throws IOException
   * If FileChannel.close() encounters an error.
   * @see java.nio.channels.FileChannel#close()
   */
  void close()
    throws IOException, InterruptedException
  {
  	// TODO: record the fact that the LOG was closed
    // write a status record at end of current journal.
    // logger will have to locate the status record during a restart.
    // status should include mark information, number of files and
    // max blocks per file.
    // alternative: write status to a separate log.status file
    
    boolean interrupted = false;
    InterruptedException exception = null;
    
    // Wait for all application data to be flushed to disk
    bmgr.flushAll();
    
    // save current configuration details to the log
    byte[] closeData = new byte[2];
    ByteBuffer closeDataBuffer = ByteBuffer.wrap(closeData);
    closeDataBuffer.clear();
    closeDataBuffer.put(crlf);
    // TODO: define content of closeData record 

    short type = LogRecordType.CTRL | LogRecordType.CLOSE;
    try {
      bmgr.put(type, closeData, false);
    } catch (LogRecordSizeException e) {
      // will never happen but use assert to catch during development
      assert e == null : "Unhandled LogRecordSizeException" + e;
    } catch (LogFileOverflowException e) {
      // ignore -- we will discover this the next time we open the logs
      // TODO: write message to system log
    } catch (InterruptedException e) {
      interrupted = true;  // remember and throw it on the way out.
      exception = e;
    }
    
    // Wait for logger information to flush to disk
    bmgr.flushAll();
  	
    // close the log files
    for (int i=0; i < fileSet.length; ++i)
    {
      fileSet[i].close();
    }
    
    if (interrupted) throw exception;
    
  }
  
  
  /**
   * Configure the LogFile pool
   */
  void configure()
  {
    // TODO: configuration code here
    maxBlocksPerFile = Integer.getInteger("howl.log.maxBlocksPerFile",maxBlocksPerFile).intValue();
    maxLogFiles = Integer.getInteger("howl.log.LogFile.maxLogFiles", maxLogFiles).intValue();
    logDir = System.getProperty("howl.log.LogFile.dir", logDir);
    logFileName = System.getProperty("howl.log.LogFile.filename", logFileName);
    logFileExt = System.getProperty("howl.log.LogFile.ext", logFileExt);
  }
  
  /**
   * Returns an XML node containing statistics for the LogFileManager.
   * <p>The nested <LogFiles> element contain entries for each
   * LogFile object in the set of log files.
   * 
   * @return a String containing statistics as an XML node.
   */
  String getStats()
  {
    String name = this.getClass().getName();

    StringBuffer stats = new StringBuffer(
        "\n<LogFileManager  class='" + name + "'>" 
        );
    
    // Append LogFileManager stats here
    stats.append("\n<initialKey value='" + Long.toHexString(initialKey) + "'>" +
          "Initial Log Key" +
        "</initialKey>" +
        "\n<currentKey value='" + Long.toHexString(currentKey) + "'>" +
          "Current Log Key" + 
        "</currentKey>" +
        "\n<restartAutoMark value='" + restartAutoMark + "'>" +
          "automark value restored from prior log file" +
        "</restartAutoMark>" +
        ""
        );

    stats.append("\n<LogFiles>");
    for (int i = 0; i < fileSet.length; ++i)
      stats.append(fileSet[i].getStats());
    stats.append("\n</LogFiles>");

    stats.append("\n</LogFileManager>");
    
    return stats.toString();
  }
}
